#!/bin/bash
#
# script for generating 10xEngineer Labs template 'precise64'
#
# Copyright © 10xEngineer, Radim Marek <radim@10xengineer.me>
#

set -e

write_sourceslist()
{
    rootfs=$1
    arch=$2
    # $3 => whether to use the multi-arch syntax or not

    case $arch in
      amd64|i386)
            MIRROR=${MIRROR:-http://eu-west-1.ec2.archive.ubuntu.com/ubuntu/}
            SECURITY_MIRROR=${SECURITY_MIRROR:-http://eu-west-1.ec2.archive.ubuntu.com/ubuntu/}
            ;;
      *)
            MIRROR=${MIRROR:-http://ports.ubuntu.com/ubuntu-ports}
            SECURITY_MIRROR=${SECURITY_MIRROR:-http://ports.ubuntu.com/ubuntu-ports}
            ;;
    esac
    if [ -n "$3" ]; then
        cat >> "$rootfs/etc/apt/sources.list" << EOF
deb [arch=$arch] $MIRROR ${release} main restricted universe multiverse
deb [arch=$arch] $MIRROR ${release}-updates main restricted universe multiverse
deb [arch=$arch] $SECURITY_MIRROR ${release}-security main restricted universe multiverse
EOF
    else
        cat >> "$rootfs/etc/apt/sources.list" << EOF
deb $MIRROR ${release} main restricted universe multiverse
deb $MIRROR ${release}-updates main restricted universe multiverse
deb $SECURITY_MIRROR ${release}-security main restricted universe multiverse
EOF
    fi
}

cleanup()
{
    rm -rf $cache/partial-$arch
    rm -rf $cache/rootfs-$arch
}

suggest_flush()
{
    echo "Container upgrade failed.  The container cache may be out of date,"
    echo "in which case flushing the case (see -F in the hep output) may help."
}

download_ubuntu()
{
    cache=$1
    arch=$2
    release=$3

    packages=vim,ssh,git,curl
    echo "installing packages: $packages"

    trap cleanup EXIT SIGHUP SIGINT SIGTERM
    # check the mini ubuntu was not already downloaded
    mkdir -p "$cache/partial-$arch"
    if [ $? -ne 0 ]; then
        echo "Failed to create '$cache/partial-$arch' directory"
        return 1
    fi

    # download a mini ubuntu into a cache
    echo "Downloading ubuntu $release minimal ..."
    if [ -n "$(which qemu-debootstrap)" ]; then
        qemu-debootstrap --verbose --components=main,universe --arch=$arch --include=$packages $release $cache/partial-$arch $MIRROR
    else
        debootstrap --verbose --components=main,universe --arch=$arch --include=$packages $release $cache/partial-$arch $MIRROR
    fi

    if [ $? -ne 0 ]; then
        echo "Failed to download the rootfs, aborting."
            return 1
    fi

    # Serge isn't sure whether we should avoid doing this when
    # $release == `distro-info -d`
    echo "Installing updates"
    > $cache/partial-$arch/etc/apt/sources.list
    write_sourceslist $cache/partial-$arch/ $arch

    chroot "$1/partial-${arch}" apt-get update
    if [ $? -ne 0 ]; then
        echo "Failed to update the apt cache"
        return 1
    fi
    cat > "$1/partial-${arch}"/usr/sbin/policy-rc.d << EOF
#!/bin/sh
exit 101
EOF
    chmod +x "$1/partial-${arch}"/usr/sbin/policy-rc.d

    lxc-unshare -s MOUNT -- chroot "$1/partial-${arch}" apt-get dist-upgrade -y || { suggest_flush; false; }
    rm -f "$1/partial-${arch}"/usr/sbin/policy-rc.d

    chroot "$1/partial-${arch}" apt-get clean

    mv "$1/partial-$arch" "$1/rootfs-$arch"
    trap EXIT
    trap SIGINT
    trap SIGTERM
    trap SIGHUP
    echo "Download complete"
    return 0
}

copy_ubuntu()
{
    cache=$1
    arch=$2
    rootfs=$3

    # make a local copy of the miniubuntu
    echo "Copying rootfs to $rootfs ..."
    mkdir -p $rootfs
    rsync -a $cache/rootfs-$arch/ $rootfs/ || return 1
    return 0
}

install_ubuntu()
{
    rootfs=$1
    release=$2
    flushcache=$3
    cache="/var/cache/lxc/$release"
    mkdir -p /var/lock/subsys/

    (
        flock -x 200
        if [ $? -ne 0 ]; then
            echo "Cache repository is busy."
            return 1
        fi


        if [ $flushcache -eq 1 ]; then
            echo "Flushing cache..."
            rm -rf "$cache/partial-$arch"
            rm -rf "$cache/rootfs-$arch"
        fi

        echo "Checking cache download in $cache/rootfs-$arch ... "
        if [ ! -e "$cache/rootfs-$arch" ]; then
            download_ubuntu $cache $arch $release
            if [ $? -ne 0 ]; then
                echo "Failed to download 'ubuntu $release base'"
                return 1
            fi
        fi

        echo "Copy $cache/rootfs-$arch to $rootfs ... "
        copy_ubuntu $cache $arch $rootfs
        if [ $? -ne 0 ]; then
            echo "Failed to copy rootfs"
            return 1
        fi

        return 0

    ) 200>/var/lock/subsys/lxc

    return $?
}

trim()
{
    rootfs=$1
    release=$2

    # provide the lxc service
    cat <<EOF > $rootfs/etc/init/lxc.conf
# fake some events needed for correct startup other services

description     "Container Upstart"

start on startup

script
        rm -rf /var/run/*.pid
        rm -rf /var/run/network/*
        /sbin/initctl emit stopped JOB=udevtrigger --no-wait
        /sbin/initctl emit started JOB=udev --no-wait
end script
EOF

    # fix buggus runlevel with sshd
    cat <<EOF > $rootfs/etc/init/ssh.conf
# ssh - OpenBSD Secure Shell server
#
# The OpenSSH server provides secure shell access to the system.

description	"OpenSSH server"

start on filesystem
stop on runlevel [!2345]

expect fork
respawn
respawn limit 10 5
umask 022
# replaces SSHD_OOM_ADJUST in /etc/default/ssh
oom never

pre-start script
    test -x /usr/sbin/sshd || { stop; exit 0; }
    test -e /etc/ssh/sshd_not_to_be_run && { stop; exit 0; }
    test -c /dev/null || { stop; exit 0; }

    mkdir -p -m0755 /var/run/sshd
end script

# if you used to set SSHD_OPTS in /etc/default/ssh, you can change the
# 'exec' line here instead
exec /usr/sbin/sshd
EOF

    cat <<EOF > $rootfs/etc/init/console.conf
# console - getty
#
# This service maintains a console on tty1 from the point the system is
# started until it is shut down again.

start on stopped rc RUNLEVEL=[2345]
stop on runlevel [!2345]

respawn
exec /sbin/getty -8 38400 /dev/console
EOF

    cat <<EOF > $rootfs/lib/init/fstab
# /lib/init/fstab: cleared out for bare-bones lxc
EOF

    # reconfigure some services
    if [ -z "$LANG" ]; then
        chroot $rootfs locale-gen en_US.UTF-8
        chroot $rootfs update-locale LANG=en_US.UTF-8
    else
        chroot $rootfs locale-gen $LANG
        chroot $rootfs update-locale LANG=$LANG
    fi

    # remove pointless services in a container
    chroot $rootfs /usr/sbin/update-rc.d -f ondemand remove

    chroot $rootfs /bin/bash -c 'cd /etc/init; for f in $(ls u*.conf); do mv $f $f.orig; done'
    chroot $rootfs /bin/bash -c 'cd /etc/init; for f in $(ls tty[2-9].conf); do mv $f $f.orig; done'
    chroot $rootfs /bin/bash -c 'cd /etc/init; for f in $(ls plymouth*.conf); do mv $f $f.orig; done'
    chroot $rootfs /bin/bash -c 'cd /etc/init; for f in $(ls hwclock*.conf); do mv $f $f.orig; done'
    chroot $rootfs /bin/bash -c 'cd /etc/init; for f in $(ls module*.conf); do mv $f $f.orig; done'

    # if this isn't lucid, then we need to twiddle the network upstart bits :(
    if [ $release != "lucid" ]; then
        sed -i 's/^.*emission handled.*$/echo Emitting lo/' $rootfs/etc/network/if-up.d/upstart
    fi
}

post_process()
{
    rootfs=$1
    release=$2

    chroot $rootfs /usr/sbin/locale-gen en_US en_US.UTF-8
    chroot $rootfs /usr/sbin/dpkg-reconfigure locales

    rm $rootfs/etc/legal

    if [ ! -f $rootfs/etc/init/container-detect.conf ]; then
        # Make sure we have a working resolv.conf
        cresolvonf="${rootfs}/etc/resolv.conf"
        mv $cresolvonf ${cresolvonf}.lxcbak
        cat /etc/resolv.conf > ${cresolvonf}

        # for lucid, if not trimming, then add the ubuntu-virt
        # ppa and install lxcguest
        if [ $release = "lucid" ]; then
            chroot $rootfs apt-get update
            chroot $rootfs apt-get install --force-yes -y python-software-properties
            chroot $rootfs add-apt-repository ppa:ubuntu-virt/ppa
        fi

        chroot $rootfs apt-get update
        chroot $rootfs apt-get install --force-yes -y lxcguest

        # Restore old resolv.conf
        rm -f ${cresolvonf}
        mv ${cresolvonf}.lxcbak ${cresolvonf}
    fi

    # rmdir /dev/shm for containers that have /run/shm
    # I'm afraid of doing rm -rf $rootfs/dev/shm, in case it did
    # get bind mounted to the host's /run/shm.  So try to rmdir
    # it, and in case that fails move it out of the way.
    if [ ! -L $rootfs/dev/shm ] && [ -d $rootfs/run/shm ] && [ -e $rootfs/dev/shm ]; then
        mv $rootfs/dev/shm $rootfs/dev/shm.bak
        ln -s /run/shm $rootfs/dev/shm
    fi
}

create_archive()
{
    tmpl_root=$1
    release=$2
    arch=$3

    date=`date +%Y%m%d_%H%M`

    archive_name="tmpl_ubuntu-${release}-${arch}-${date}.tar.gz"

    cwd=`pwd`
    cd $tmpl_root

    tar -cz -f ${cwd}/$archive_name ./

    cd $cwd

    echo "Archive name ${archive_name}"
}

usage()
{
    cat <<EOF
$1 -h|--help [-a|--arch] [-d|--debug]
   [-F | --flush-cache] [-r|--release <release>]
release: the ubuntu release (e.g. precise): defaults to host release on ubuntu, otherwise uses latest LTS
arch: the container architecture (e.g. amd64): defaults to host arch
EOF
    return 0
}

options=$(getopt -o a:hr:n:Kd -l arch:,help,release:,name:,keep-cache,debug -- "$@")
if [ $? -ne 0 ]; then
    usage $(basename $0)
    exit 1
fi
eval set -- "$options"

release=precise # Default to the last Ubuntu LTS release for non-Ubuntu systems
if [ -f /etc/lsb-release ]; then
    . /etc/lsb-release
    if [ "$DISTRIB_ID" = "Ubuntu" ]; then
        release=$DISTRIB_CODENAME
    fi
fi

arch=$(arch)

# Code taken from debootstrap
if [ -x /usr/bin/dpkg ] && /usr/bin/dpkg --print-architecture >/dev/null 2>&1; then
    arch=`/usr/bin/dpkg --print-architecture`
elif type udpkg >/dev/null 2>&1 && udpkg --print-architecture >/dev/null 2>&1; then
    arch=`/usr/bin/udpkg --print-architecture`
else
    arch=$(arch)
    if [ "$arch" = "i686" ]; then
        arch="i386"
    elif [ "$arch" = "x86_64" ]; then
        arch="amd64"
    fi
fi

debug=0
hostarch=$arch
flushcache=1
while true
do
    case "$1" in
    -h|--help)      usage $0 && exit 0;;
    -K|--keep-cache) flushcache=0; shift 1;;
    -r|--release)   release=$2; shift 2;;
    -a|--arch)      arch=$2; shift 2;;
    -d|--debug)     debug=1; shift 1;;
    --)             shift 1; break ;;
        *)              break ;;
    esac
done

if [ $debug -eq 1 ]; then
    set -x
fi


if [ "$arch" == "i686" ]; then
    arch=i386
fi

if [ $hostarch = "i386" -a $arch = "amd64" ]; then
    echo "can't create amd64 container on i386"
    exit 1
fi

type debootstrap
if [ $? -ne 0 ]; then
    echo "'debootstrap' command is missing"
    exit 1
fi

if [ "$(id -u)" != "0" ]; then
    echo "This script should be run as 'root'"
    exit 1
fi

# setup temporary path for rootfs
tmpl_root=`/bin/mktemp -d`
rootfs=${tmpl_root}/rootfs

mkdir -p rootfs

cp -R templates/ubuntu-precise/* $tmpl_root/

install_ubuntu $rootfs $release $flushcache
if [ $? -ne 0 ]; then
    echo "failed to install ubuntu $release"
    exit 1
fi

post_process $rootfs $release 
create_archive $tmpl_root $release $arch

rm -Rf $rootfs